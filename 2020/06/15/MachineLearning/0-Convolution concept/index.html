<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="keywords" content="hexo,个人博客,blog">
  <meta name="description" content="焕小妹的个人博客">
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="dns-prefetch" href="https://busuanzi.ibruce.info">
  <link rel="dns-prefetch" href="https://at.alicdn.com">
  
  <link rel="dns-prefetch" href="https://widget.daovoice.io">
  <link rel="dns-prefetch" href="https://widget-static-cdn.daovoice.io">
  <link rel="dns-prefetch" href="https://im.daovoice.io">
  
  
  <link rel="dns-prefetch" href="https://hm.baidu.com/">
  
  
  <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
  <link rel="dns-prefetch" href="https://api.github.com">
  <link rel="dns-prefetch" href="https://avatars3.githubusercontent.com">
  
  <link rel="stylesheet" type="text/css" href="/./style/main.css">
	<link rel="shortcut icon" href="/favicon.ico" title="Favicon">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
	<title>对卷积的定义和意义的通俗解释</title>
  
  <script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?be13bf98b13bee6a1fc89b6ae36a8ffb";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();
  </script>
  
  
    <script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/a1aef33b.js","daovoice");daovoice('init',{app_id: "a1aef33b"});daovoice('update');
  </script>
  
</head>
<body>
  <canvas id="pattern-placeholder" height="230"></canvas>
<div class="navbar-header">
  <a class="blog-title" href="/">焕小妹</a>
  <a class="face-img" href="/">
    <img src="https://github.com/HuanwenW/MyPostImag/blob/master/190410-boke/touxiang-1.jpg?raw=true">
  </a>
</div>
<main>
  <div class="article-title">
    
  
  <h1 class="title">
    对卷积的定义和意义的通俗解释
  </h1>
  


    <ul class="article-info">
      <li>
        发布
        <time datetime="2020-06-15T02:45:17.000Z" itemprop="datePublished">2020-06-15</time>
      </li>
      <li>
        
    更新 <time datetime="2020-06-15T02:45:37.281Z" itemprop="dateUpdated">2020-06-15</time>

      </li>
      <li id="busuanzi_container_page_pv">
        阅读 <span id="busuanzi_value_page_pv"></span>
      </li>
    </ul>
  </div>
  <div class="container">
    <div class="article">
      <div class="content">
        
        <div class="overdue-remind">
          本文最后更新于$day天前，文中所描述的信息可能已发生改变。
        </div>
        
        <h1 id="对卷积的定义和意义的通俗解释"><a href="#对卷积的定义和意义的通俗解释" class="headerlink" title="对卷积的定义和意义的通俗解释"></a>对卷积的定义和意义的通俗解释</h1><p>教科书上一般定义函数<img src="https://www.zhihu.com/equation?tex=f%2Cg" alt="f,g">的卷积<img src="https://www.zhihu.com/equation?tex=%28f%2Ag%29%28n%29" alt="(f*g)(n)">如下：</p>
<p>连续形式：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cdisplaystyle+%28f%2Ag%29%28n%29%3D%5Cint+_%7B-%5Cinfty+%7D%5E%7B%5Cinfty+%7Df%28%5Ctau+%29g%28n-%5Ctau+%29d%5Ctau+%5C%5C" alt="\displaystyle (f*g)(n)=\int _{-\infty }^{\infty }f(\tau )g(n-\tau )d\tau \\"></p>
<p>离散形式：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cdisplaystyle+%28f%2Ag%29%28n%29%3D%5Csum+_%7B%5Ctau+%3D-%5Cinfty+%7D%5E%7B%5Cinfty+%7D%7Bf%28%5Ctau+%29g%28n-%5Ctau+%29%7D%5C%5C" alt="\displaystyle (f*g)(n)=\sum _{\tau =-\infty }^{\infty }{f(\tau )g(n-\tau )}\\"></p>
<ul>
<li><p>公式解释，先对g函数进行翻转，相当于在数轴上把g函数从右边褶到左边去，也就是卷积的“卷”的由来。</p>
</li>
<li><p>然后再把g函数平移到n，在这个位置对两个函数的对应点相乘，然后相加，这个过程是卷积的“积”的过程。</p>
</li>
</ul>
<p>这个只是从计算的方式上对公式进行了解释，从数学上讲无可挑剔，但进一步追问，为什么要先翻转再平移，这么设计有何用意？还是有点费解的。</p>
<p>好在有万能的互联网，尤其是知乎，CSDN这样的网站，很多的热心网友对卷积举了很多形象的例子进行了解释，如卷地毯、丢骰子、打耳光、存钱等等，参见知乎上这两个两个经典的问题，回答的人很多：</p>
<p><a href="https://www.zhihu.com/question/22298352/answer/228543288" target="_blank" rel="noopener">如何通俗易懂地解释<em>卷积</em>？</a><a href="https://www.zhihu.com/question/22298352" target="_blank" rel="noopener">https://www.zhihu.com/question/22298352</a></p>
<p><a href="https://www.zhihu.com/question/54677157/answer/141245297" target="_blank" rel="noopener"><em>卷积</em>为什么叫「卷」积？</a> <a href="https://www.zhihu.com/question/54677157" target="_blank" rel="noopener">https://www.zhihu.com/question/54677157</a></p>
<p>读完觉得非常生动有趣，但过细想想，还是感觉有些地方还是没解释清楚，甚至可能还有瑕疵，或者还可以改进（这些后面我会做一些分析）。</p>
<p>==明确一下，这篇文章主要想解释两个问题：==</p>
<ol>
<li><p><strong>卷积这个名词是怎么解释？“卷”是什么意思？“积”又是什么意思？</strong></p>
</li>
<li><p><strong>卷积背后的意义是什么，该如何解释？</strong></p>
</li>
</ol>
<h3 id="对卷积的理解"><a href="#对卷积的理解" class="headerlink" title="对卷积的理解"></a>对卷积的理解</h3><p>对卷积这个名词的理解：所谓两个函数的卷积，本质上就是先将一个函数翻转，然后进行滑动叠加。</p>
<p>在连续情况下，叠加指的是对两个函数的乘积求积分，在离散情况下就是加权求和，为简单起见就统一称为叠加。</p>
<p>整体看来是这么个过程：</p>
<p>​        翻转——&gt;滑动——&gt;叠加——&gt;滑动——&gt;叠加——&gt;滑动——&gt;叠加…..</p>
<p>多次滑动得到的一系列叠加值，构成了卷积函数。</p>
<p><strong>卷积的“卷”，指的的函数的翻转，从 <em>g(t)</em> 变成 <em>g(-t)</em> 的这个过程；</strong></p>
<p><strong>卷积的“积”，指的是滑动积分/加权求和。</strong></p>
<p>有些文章只强调滑动叠加求和，而没有说函数的翻转，我觉得是不全面的；有的文章对“卷”的理解其实是“积”，我觉得是张冠李戴。</p>
<p>==对卷积的意义的理解：==</p>
<ol>
<li><p>从“积”的过程可以看到，我们得到的叠加值，是个全局的概念。以<strong>信号分析</strong>为例，卷积的结果是不仅跟当前时刻输入信号的响应值有关，也跟过去所有时刻输入信号的响应都有关系，考虑了对过去的所有输入的效果的累积。在图像处理的中，卷积处理的结果，其实就是把每个像素周边的，甚至是整个图像的像素都考虑进来，对当前像素进行某种加权处理。所以说，“积”是全局概念，或者说是一种“混合”，把两个函数在时间或者空间上进行混合。</p>
</li>
<li><p>那为什么要进行“卷”？直接相乘不好吗？我的理解，进行“卷”（翻转）的目的其实是施加一种约束，它指定了在“积”的时候以什么为参照。在<strong>信号分析</strong>的场景，它指定了在哪个特定时间点的前后进行“积”，在空间分析的场景，它指定了在哪个位置的周边进行累积处理。</p>
</li>
</ol>
<h2 id="考虑的应用场景"><a href="#考虑的应用场景" class="headerlink" title="考虑的应用场景"></a>考虑的应用场景</h2><p>为了更好地理解这些问题，我们先给出两个典型的应用场景：</p>
<ol>
<li><strong>信号分析</strong></li>
</ol>
<p>一个输入信号<em>f(t)</em>，经过一个线性系统（其特征可以用单位冲击响应函数<em>g(t)</em>描述）以后，输出信号应该是什么？<u>实际上通过卷积运算就可以得到输出信号。</u></p>
<ol start="2">
<li><strong>图像处理</strong></li>
</ol>
<p>输入一幅图像<em>f(x,y)</em>，经过特定设计的卷积核<em>g(x,y)</em>进行卷积处理以后，输出图像将会得到模糊，边缘强化等各种效果。</p>
<h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>下面举几个例子说明为什么要翻转，以及叠加求和的意义。</p>
<h4 id="例1：信号分析"><a href="#例1：信号分析" class="headerlink" title="例1：信号分析"></a>例1：信号分析</h4><p>如下图所示，输入信号是 <em>f(t)</em> ，是随时间变化的。系统响应函数是 <em>g(t)</em> ，图中的响应函数是随时间指数下降的，它的物理意义是说：如果在 <em>t</em>=0 的时刻有一个输入，那么随着时间的流逝，这个输入将不断衰减。换言之，到了 <em>t</em>=T时刻，原来在 <em>t</em>=0 时刻的输入<em>f</em>(0)的值将衰减为<em>f</em>(0)<em>g</em>(T)。</p>
<p><img src="https://img-blog.csdnimg.cn/20190329202607222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbGV0,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>考虑到信号是连续输入的，也就是说，每个时刻都有新的信号进来，所以，最终输出的是所有之前输入信号的累积效果。如下图所示，在T=10时刻，输出结果跟图中带标记的区域整体有关。其中，f(10)因为是刚输入的，所以其输出结果应该是f(10)g(0)，而时刻t=9的输入f(9)，只经过了1个时间单位的衰减，所以产生的输出应该是 f(9)g(1)，如此类推，即图中虚线所描述的关系。这些对应点相乘然后累加，就是T=10时刻的输出信号值，这个结果也是f和g两个函数在T=10时刻的卷积值。</p>
<p><img src="https://img-blog.csdnimg.cn/20190329202801773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbGV0,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>显然，上面的对应关系看上去比较难看，是拧着的，所以，我们把g函数对折一下，变成了g(-t)，这样就好看一些了。看到了吗？这就是为什么卷积要“卷”，要翻转的原因，这是从它的物理意义中给出的。</p>
<p><img src="https://img-blog.csdnimg.cn/20190329202917661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbGV0,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>上图虽然没有拧着，已经顺过来了，但看上去还有点错位，所以再进一步平移T个单位，就是下图。它就是本文开始给出的卷积定义的一种图形的表述：</p>
<p><img src="https://img-blog.csdnimg.cn/2019032920295542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbGV0,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>所以，在以上计算T时刻的卷积时，要维持的约束就是： ==<em>t+ (T-t) = T</em>== 。这种约束的意义，大家可以自己体会。</p>
<h4 id="例2：丢骰子"><a href="#例2：丢骰子" class="headerlink" title="例2：丢骰子"></a>例2：丢骰子</h4><p>在知乎问题 <a href="https://www.zhihu.com/question/22298352/answer/228543288" target="_blank" rel="noopener">如何通俗易懂地解释卷积</a>？中排名第一的 <a href="https://www.zhihu.com/people/matongxue" target="_blank" rel="noopener">马同学</a>在中举了一个很好的例子（下面的一些图摘自马同学的文章，在此表示感谢），用丢骰子说明了卷积的应用。</p>
<p>要解决的问题是：有两枚骰子，把它们都抛出去，两枚骰子点数加起来为4的概率是多少?</p>
<p><img src="https://images2017.cnblogs.com/blog/1235843/201711/1235843-20171119211259577-925832671.jpg" alt="img"></p>
<p>分析一下，两枚骰子点数加起来为4的情况有三种情况：1+3=4， 2+2=4, 3+1=4</p>
<p>因此，两枚骰子点数加起来为4的概率为：<img src="https://img-blog.csdnimg.cn/2019033010404399.png" alt="img"></p>
<p>写成卷积的方式就是：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cdisplaystyle+%28f%2Ag%29%284%29%3D%5Csum+_%7Bm%3D1%7D%5E%7B3%7Df%284-m%29g%28m%29%5C%5C" alt="\displaystyle (f*g)(4)=\sum _{m=1}^{3}f(4-m)g(m)\\"></p>
<p>在这里我想进一步用上面的翻转滑动叠加的逻辑进行解释。</p>
<p>首先，因为两个骰子的点数和是4，为了满足这个约束条件，我们还是把函数 g 翻转一下，然后阴影区域上下对应的数相乘，然后累加，相当于求自变量为4的卷积值，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20190330150427489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbGV0,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>进一步，如此翻转以后，可以方便地进行推广去求两个骰子点数和为 <em>n</em> 时的概率，为<em>f</em> 和 <em>g</em>的卷积 <em>f\</em>g(n)*，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20190330150928506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbGV0,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>由上图可以看到，函数 <em>g</em> 的滑动，带来的是点数和的增大。这个例子中对f和g的约束条件就是点数和，它也是卷积函数的自变量。有兴趣还可以算算，如果骰子的每个点数出现的概率是均等的，那么两个骰子的点数和n=7的时候，概率最大。</p>
<h4 id="例3：图像处理"><a href="#例3：图像处理" class="headerlink" title="例3：图像处理"></a>例3：图像处理</h4><p>还是引用知乎问题 <a href="https://www.zhihu.com/question/22298352/answer/228543288" target="_blank" rel="noopener">如何通俗易懂地解释卷积</a>？中 <a href="https://www.zhihu.com/people/matongxue" target="_blank" rel="noopener">马同学</a>的例子。图像可以表示为矩阵形式（下图摘自马同学的文章）：</p>
<p><img src="https://pic3.zhimg.com/v2-8dd14775ab8c91a09507f52e44f347f3_r.jpg" alt="preview"></p>
<p>对图像的处理函数（如平滑，或者边缘提取），也可以用一个g矩阵来表示，如：</p>
<p><img src="https://private.codecogs.com/gif.latex?g%3D%5Cbegin%7Bbmatrix%7D%20%26b_%7B-1%2C-1%7D%20%26b_%7B-1%2C0%7D%20%26b_%7B-1%2C1%7D%5C%5C%20%26b_%7B0%2C-1%7D%20%26b_%7B0%2C0%7D%20%26b_%7B0%2C1%7D%20%5C%5C%20%26b_%7B1%2C-1%7D%20%26b_%7B1%2C0%7D%20%26b_%7B1%2C1%7D%20%5Cend%7Bbmatrix%7D" alt="g=\begin{bmatrix} &amp;b_{-1,-1} &amp;b_{-1,0} &amp;b_{-1,1}\\ &amp;b_{0,-1} &amp;b_{0,0} &amp;b_{0,1} \\ &amp;b_{1,-1} &amp;b_{1,0} &amp;b_{1,1} \end{bmatrix}"></p>
<p>注意，我们在处理平面空间的问题，已经是二维函数了，相当于：</p>
<p><img src="https://private.codecogs.com/gif.latex?f%28x%2Cy%29%3Da_%7Bx%2Cy%7D" alt="f(x,y)=a_{x,y}">    <img src="https://private.codecogs.com/gif.latex?g%28x%2Cy%29%3Db_%7Bx%2Cy%7D" alt="g(x,y)=b_{x,y}">   </p>
<p>那么函数f和g的在（u，v）处的卷积 <img src="https://private.codecogs.com/gif.latex?f*g%28u%2Cv%29" alt="f*g(u,v)">该如何计算呢？</p>
<p><img src="https://img-blog.csdnimg.cn/20190330170548724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbGV0,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>首先我们在原始图像矩阵中取出（u,v）处的矩阵：【u代表纵向，v代表横向，矩阵坐标是表示相对位置，而==不是==坐标系中的象限坐标(上加下减，左减右加)-hh】</p>
<p><img src="https://private.codecogs.com/gif.latex?f%3D%5Cbegin%7Bbmatrix%7D%20%26a_%7Bu-1%2Cv-1%7D%20%26a_%7Bu-1%2Cv%7D%20%26a_%7Bu-1%2Cv&plus;1%7D%5C%5C%20%26a_%7Bu%2Cv-1%7D%20%26a_%7Bu%2Cv%7D%20%26a_%7Bu%2Cv&plus;1%7D%20%5C%5C%20%26a_%7Bu&plus;1%2Cv-1%7D%20%26a_%7Bu&plus;1%2Cv%7D%20%26a_%7Bu&plus;1%2Cv&plus;1%7D%20%5Cend%7Bbmatrix%7D" alt="f=\begin{bmatrix} &amp;a_{u-1,v-1} &amp;a_{u-1,v} &amp;a_{u-1,v+1}\\ &amp;a_{u,v-1} &amp;a_{u,v} &amp;a_{u,v+1} \\ &amp;a_{u+1,v-1} &amp;a_{u+1,v} &amp;a_{u+1,v+1} \end{bmatrix}"></p>
<p>然后将图像处理矩阵翻转（延x轴和y轴两个方向翻转），如下：</p>
<p><img src="https://private.codecogs.com/gif.latex?g%5E%7B%27%7D%3D%5Cbegin%7Bbmatrix%7D%20%26b_%7B1%2C1%7D%20%26b_%7B1%2C0%7D%20%26b_%7B1%2C-1%7D%5C%5C%20%26b_%7B0%2C1%7D%20%26b_%7B0%2C0%7D%20%26b_%7B0%2C-1%7D%20%5C%5C%20%26b_%7B-1%2C1%7D%20%26b_%7B-1%2C0%7D%20%26b_%7B-1%2C-1%7D%20%5Cend%7Bbmatrix%7D" alt="g^{&#39;}=\begin{bmatrix} &amp;b_{1,1} &amp;b_{1,0} &amp;b_{1,-1}\\ &amp;b_{0,1} &amp;b_{0,0} &amp;b_{0,-1} \\ &amp;b_{-1,1} &amp;b_{-1,0} &amp;b_{-1,-1} \end{bmatrix}"></p>
<p>计算卷积时，就可以用<img src="https://private.codecogs.com/gif.latex?f" alt="f">和<img src="https://private.codecogs.com/gif.latex?g%5E%7B%27%7D" alt="g^{&#39;}">的内积：</p>
<p><img src="https://private.codecogs.com/gif.latex?f*g%28u%2Cv%29%3Da_%7Bu-1%2Cv-1%7D%20%5Ctimes%20b_%7B1%2C1%7D%20&plus;%20a_%7Bu-1%2Cv%7D%20%5Ctimes%20b_%7B1%2C0%7D%20&plus;%20a_%7Bu-1%2Cv&plus;1%7D%20%5Ctimes%20b_%7B1%2C-1%7D%20&plus;%20a_%7Bu%2Cv-1%7D%20%5Ctimes%20b_%7B0%2C1%7D%20&plus;%20a_%7Bu%2Cv%7D%20%5Ctimes%20b_%7B0%2C0%7D%20&plus;%20a_%7Bu%2Cv&plus;1%7D%20%5Ctimes%20b_%7B0%2C-1%7D%20&plus;%20a_%7Bu&plus;1%2Cv-1%7D%20%5Ctimes%20b_%7B-1%2C1%7D%20&plus;%20a_%7Bu&plus;1%2Cv%7D%20%5Ctimes%20b_%7B-1%2C0%7D%20&plus;%20a_%7Bu&plus;1%2Cv&plus;1%7D%20%5Ctimes%20b_%7B-1%2C-1%7D" alt="f*g(u,v)=a_{u-1,v-1} \times b_{1,1} + a_{u-1,v} \times b_{1,0} + a_{u-1,v+1} \times b_{1,-1} + a_{u,v-1} \times b_{0,1} + a_{u,v} \times b_{0,0} + a_{u,v+1} \times b_{0,-1} + a_{u+1,v-1} \times b_{-1,1} + a_{u+1,v} \times b_{-1,0} + a_{u+1,v+1} \times b_{-1,-1}"></p>
<p>请注意，以上公式有一个特点，做乘法的两个对应变量a,b的下标之和都是（u,v），其目的是对这种加权求和进行一种约束。这也是为什么要将矩阵g进行翻转的原因。</p>
<p>以上计算的是（u,v）处的卷积，延x轴或者y轴滑动，就可以求出图像中各个位置的卷积，其输出结果是处理以后的图像（即经过平滑、边缘提取等各种处理的图像）。</p>
<p>再深入思考一下，在算图像卷积的时候，我们是直接在原始图像矩阵中取了（u,v）处的矩阵，为什么要取这个位置的矩阵，本质上其实是为了满足以上的约束。因为我们要算（u，v）处的卷积，而g矩阵是3x3的矩阵，要满足下标跟这个3x3矩阵的和是（u,v），只能是取原始图像中以（u，v）为中心的这个3x3矩阵，即图中的阴影区域的矩阵。</p>
<p>==【下面仅是摘录，并未理解-hh】==</p>
<p>推而广之，如果如果g矩阵不是3x3，而是6x6，那我们就要在原始图像中取以（u，v）为中心的6x6矩阵进行计算。由此可见，这种卷积就是把原始图像中的相邻像素都考虑进来，进行混合。相邻的区域范围取决于g矩阵的维度，维度越大，涉及的周边像素越多。而矩阵的设计，则决定了这种混合输出的图像跟原始图像比，究竟是模糊了，还是更锐利了。</p>
<p>比如说，如下图像处理矩阵将使得图像变得更为平滑，显得更模糊，因为它联合周边像素进行了平均处理：</p>
<p><img src="https://private.codecogs.com/gif.latex?g%3D%5Cbegin%7Bbmatrix%7D%20%26%5Cfrac%7B1%7D%7B9%7D%20%26%5Cfrac%7B1%7D%7B9%7D%20%26%5Cfrac%7B1%7D%7B9%7D%5C%5C%20%26%5Cfrac%7B1%7D%7B9%7D%20%26%5Cfrac%7B1%7D%7B9%7D%20%26%5Cfrac%7B1%7D%7B9%7D%20%5C%5C%20%26%5Cfrac%7B1%7D%7B9%7D%20%26%5Cfrac%7B1%7D%7B9%7D%20%26%5Cfrac%7B1%7D%7B9%7D%20%5Cend%7Bbmatrix%7D" alt="g=\begin{bmatrix} &amp;\frac{1}{9} &amp;\frac{1}{9} &amp;\frac{1}{9}\\ &amp;\frac{1}{9} &amp;\frac{1}{9} &amp;\frac{1}{9} \\ &amp;\frac{1}{9} &amp;\frac{1}{9} &amp;\frac{1}{9} \end{bmatrix}"> </p>
<p>而如下图像处理矩阵将使得像素值变化明显的地方更为明显，强化边缘，而变化平缓的地方没有影响，达到提取边缘的目的：</p>
<p><img src="https://private.codecogs.com/gif.latex?g%3D%5Cbegin%7Bbmatrix%7D%20%26-1%20%26-1%20%26-1%5C%5C%20%26-1%20%269%20%26-1%20%5C%5C%20%26-1%20%26-1%20%26-1%20%5Cend%7Bbmatrix%7D" alt="g=\begin{bmatrix} &amp;-1 &amp;-1 &amp;-1\\ &amp;-1 &amp;9 &amp;-1 \\ &amp;-1 &amp;-1 &amp;-1 \end{bmatrix}"></p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p><a href="https://www.cnblogs.com/delphi-xe5/p/11373199.html" target="_blank" rel="noopener">对卷积的定义和意义的通俗解释-物理角度从一维升级为二维</a></p>

      </div>
        <div class="support-author">
          <p>感谢您的阅读。 🙏
          <a href="https://huanwenw.github.io/2019/09/12/copyright-reprinted/" target="_blank">关于转载请看这里</a>
            <!--<a class="btn-pay"  href="#pay-modal">¥ 打赏支持</a>-->
          </p>
        </div>
        <!--
            <div class="like ">
              <div class="like-button">
                <a id="like-note" href="">
                  <i class="icon-heart"></i>喜欢
                </a>
              </div>
              <span id="likes-count">256</span>
            </div>
        -->
        <div class="otherLink">
          <div class="previous">
          </div>
          <div class="next">
          </div>
        </div>
        <div class="comments" id="comments">
          
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script type="text/javascript">
  const gitalk = new Gitalk({
    clientID: '90a1036ad9349c8b0510',
    clientSecret: '5d7693cc0914fa1b34f43bebc0eb1384f2614759',
    repo: 'https://github.com/HuanwenW/HuanwenW.gitHub.io',
    owner: 'HuanwenW',
    admin: ['HuanwenW'],
    id: location.pathname,      // Ensure uniqueness and length less than 50
    distractionFreeMode: false
  })

  gitalk.render('comments');
</script>


        </div>
      </div>
    </div>
   
</main>
<div class="footer">
  <div class="info">
    <p>
    <a href="https://hexo.io"> Hexo </a> 强力驱动 |
      <a href="https://github.com/Youthink/hexo-themes-yearn"> Yearn </a>
      主题
    </p>
    <p>&copy;2019-2021 焕小妹的博客 豫ICP备1023号</p>
  </div>
</div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script>//console
  var consoleConfig = '\n欢迎访问 https://huanwenw.github.io ，围观小猿大圣的博客(づ｡◕‿‿◕｡)づ！\n,\n本博客使用 %cHexo%c 搭建，博客主题为小猿大圣开发的 %chexo-themes-yearn%c ~~~ 🎉🎉🎉 \n\n源码 https://github.com/Youthink/hexo-themes-yearn \n\n如果喜欢可以 star 支持一下 ❤️~\n,\n扫描下面的二维码，在手机上查看博客！\n,https://static.hufangyun.com/blog-url-qrcode-180-180.png,\n 想知道这个效果如何实现的？博客内搜索 console 彩蛋 🚀 ！\n'.split(',');
  var canConsole = true;
  var consoleInfo = (function(consoleConfig) {
  if (!canConsole || !consoleConfig || consoleConfig.length < 1) {
    return;
  }
  var consoleColor = '#6190e8';
  var _console;
  var backgroundTextStyle = 'padding: 1px 5px;color: #fff;background: ' + consoleColor + ';'
  var textStyle = 'color: ' + consoleColor + ';';

  consoleConfig.map(o => {
    var num = (o.match(/%c/g) || []).length;
    if(/^http(s)?:\/\//.test(o)) {
      console.log('%c     ', 'background: url(' + o + ') no-repeat left center;font-size: 180px;');
      return;
    }
    if (num > 0) {
      var logArguments = [];
      for (var i = 0; i < num; i++) {
        if (i % 2 === 0) {
          logArguments.push(backgroundTextStyle);
        } else {
          logArguments.push(textStyle);
        }
      }
      (_console = console).log.apply(_console, ['%c' + o, textStyle].concat(logArguments));
      return;
    }
    console.log('%c' + o, textStyle);
  });
}(consoleConfig));</script><script type="text/javascript" src="/./js/main.js"></script>

  <script src="//at.alicdn.com/t/font_159214_mvtxvg9me9.js"></script>
</body>
</html>
